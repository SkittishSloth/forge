# Template System Specification

This document provides a detailed specification for the Forge template system.

## Template Discovery

Forge discovers templates by walking up the directory tree from the current working directory, looking for a `.forge/templates/` directory. It will continue searching up to the user's home directory (`$HOME/.forge/templates/`).

- Project-level templates take precedence over user-level templates.
- Within a `.forge/templates/` directory, each subdirectory is considered a template set.
- Template sets can contain one or more templates, defined by the `forge.meta.yaml` file within a subdirectory of the template set.

## Template Set Structure

A template set directory (e.g., `.forge/templates/my_templates/`) contains subdirectories, each representing a distinct template.

```
.forge/templates/
└── my_templates/
    ├── my_template_one/
    │   ├── forge.meta.yaml
    │   └── template_files/
    │       └── ... (template files with .j2 extension)
    └── my_template_two/
        ├── forge.meta.yaml
        └── template_files/
            └── ... (template files with .j2 extension)
```
## `forge.meta.yaml` Specification

The `forge.meta.yaml` file is the core configuration for a template. It is a YAML file with the following top-level keys:

### `name` (Required)

The name of the template. This is used to identify the template when running commands like `forge new project --template <template_name>`.

### `description` (Optional)

A brief description of what the template does.

### `files` (Optional)

A list of files to be generated by this template. Each item in the list is an object with the following keys:

-   `path` (Required): The output path for the generated file. This path can contain Jinja2 variables.
-   `template` (Required): The path to the Jinja2 template file relative to the `template_files/` directory.
-   `when` (Optional): A Jinja2 expression that must evaluate to true for the file to be generated.

Example `files` entry:

```yaml
files:
  - path: "{{ project_name | snake_case }}/{{ file_name | snake_case }}.py"
    template: "template.py.j2"
    when: "{{ include_python_file | default(true) }}"
```
### `modifications` (Optional)

A list of modifications to be applied to existing files. Each item in the list is an object with the following keys:

-   `file` (Required): The path to the file to modify. This path can contain Jinja2 variables.
-   `region` (Required): The name of the marker region within the target file (e.g., `imports`, `commands`).
-   `template` (Required): The path to the Jinja2 template file containing the content to inject, relative to the `template_files/` directory.
-   `value_source` (Optional): Specifies how to source data for injecting multiple items. Currently supported: `directory`.
    -   If `value_source: directory`, an additional `path` key is required under `value_source` specifying the directory to scan. The data available in the template will be a list of filenames found in that directory.
-   `mode` (Optional): The injection mode. Currently supported: `block` (injects the entire template content once) and `block_per_item` (injects the template content for each item sourced by `value_source`). Defaults to `block`.

Example `modifications` entry:
```yaml
modifications:
  - file: "main.py"
    region: "imports"
    template: "imports.py.j2"
  - file: "cli.py"
    region: "commands"
    template: "command_registration.py.j2"
    value_source:
      directory: "commands/"
    mode: block_per_item
```
### `variables` (Optional)

A dictionary of variables that can be used within the template files, file paths, and `when` expressions. These can have default values and can be overridden by command-line arguments or other configuration sources.

Example `variables` entry:
```yaml
variables:
  project_name:
    description: "The name of the project."
    default: "my_project"
  include_tests:
    description: "Whether to include test files."
    default: true
```
## Template Files

Template files are standard text files that use Jinja2 syntax for templating. They typically have a `.j2` extension. These files are located within the `template_files/` directory of a template.

## Custom Jinja2 Filters

Forge provides several custom Jinja2 filters for common string manipulation tasks:

-   `snake_case`: Converts a string to snake_case (e.g., "My Project" -> "my_project").
-   `kebab_case`: Converts a string to kebab-case (e.g., "My Project" -> "my-project").
-   `fqn_to_path`: Converts a fully qualified name (e.g., "my_module.my_class") to a file path (e.g., "my_module/my_class.py"). (Note: The `.py` extension should be added separately in the `path` key of the `files` section).

## Smart Code Injection Markers

Forge's smart code injection relies on special comment markers within target files. These markers define regions where content can be inserted.

The marker format is: `# forge:<region>:<optional_item_name>:<start|end>`.

-   `<region>`: The name of the region, matching the `region` specified in the `modifications` section of `forge.meta.yaml`.
-   `<optional_item_name>`: Used in `block_per_item` mode to identify the start and end of content injected for a specific item.
-   `<start|end>`: Indicates the beginning or end of the marked region.

Example markers in a Python file:
```python
# forge:imports:start
# forge:imports:end

# forge:commands:start
# forge:commands:my_command:start
# This is the injected content for 'my_command'.
# forge:commands:my_command:end
# forge:commands:another_command:start
# This is the injected content for 'another_command'.
# forge:commands:another_command:end
# forge:commands:end
```
When using `mode: block`, the `optional_item_name` part of the marker is omitted. When using `mode: block_per_item`, Forge will look for markers that include the specific item name.